From lrust.typing Require Export type.
From lrust.typing Require Import uniq_util typing ptr always_true hints uniq_alt.
From lrust.util Require Import list.
From lrust.typing.lib.ghostptrtoken Require Import ghostptrtoken heap_util ghostptrtoken_basic.
Set Default Proof Using "Type".

Open Scope nat.

Implicit Type ùîÑ ùîÖ: syn_type.

Section ghostptrtoken_mut.
  Context `{!typeG Œ£}.

  Definition ghostptrtoken_mut_mod {ùîÑ} (ll: list loc): ((list‚Çõ (loc‚Çõ * ùîÑ)) * (list‚Çõ (loc‚Çõ * ùîÑ)))%ST -> ((list‚Çõ (loc‚Çõ * ùîÑ)) * (list‚Çõ (loc‚Çõ * ùîÑ)))%ST :=
    prod_map id (filter (Œª '(l, v), l ‚àâ ll)).

  Definition ghostptrtoken_ty_uniq_alt_base {ùîÑ} (ty: type ùîÑ) Œ∫ vœÄ d tid vl :=
    (‚àÉ(ll: (list loc)) vœÄ', ‚åúvœÄ = (ghostptrtoken_mut_mod ll) ‚àò vœÄ'‚åù ‚àó ([‚àó list] l ‚àà ll, &at{Œ∫, lftN} (‚Ä†{1}l‚Ä¶(ty_size ty))) ‚àó ty_own (&uniq{Œ∫} (ghostptrtoken_ty ty)) vœÄ' d tid vl)%I.

  Program Global Instance ghostptrtoken_ty_uniq {ùîÑ} (ty: type ùîÑ): UniqAlt (ghostptrtoken_ty ty) := {
    ty_uniq_alt Œ∫ := 
    if (decide ((ty_size ty) > 0)%Z) 
       then ghostptrtoken_ty_uniq_alt_base ty Œ∫
       else (ty_own (&uniq{Œ∫} (ghostptrtoken_ty ty)));
  }.
  Next Obligation. intros. destruct (decide ((ty_size ty) > 0)%Z); [|eapply (@ty_uniq_alt_out _ _ _ (ghostptrtoken_ty ty) (base_ty_uniq _))].
    iIntros "(%&%&->&#‚Ä†s&?)". iExists _, _. iFrame. iSplit. done. iSplit. iIntros (????) "?". iExists _, _. iFrame. iFrame "‚Ä†s". done.
    iIntros (?????) "#LFT #PROPH Œ∫ token". rewrite ghostptrtoken_own_alt.  iDestruct "token" as (?) "(>[->->]&token)".
    iExists' aœÄl. iDestruct "token" as "($&owns)".
    iAssert (|={_}=>  ‚åúForall (Œª '(l, _), l ‚àâ ll) aœÄl‚åù  ‚àó q.[Œ∫] ‚àó ‚ñ∑ (big_sepL _ _))%I with "[-]" as ">(%&$&$)".
    iInduction aœÄl as [|[??]?] "IH". iFrame. done. simpl. iDestruct "owns" as "(own&owns)". 
    rewrite Forall_cons bi.pure_and. iMod ("IH" with "Œ∫ owns") as "($&Œ∫&$)". iClear "IH".
    iInduction ll as [|] "IH". iFrame. iModIntro. iPureIntro. apply not_elem_of_nil. simpl. iDestruct "‚Ä†s" as "(‚Ä†&‚Ä†s)".
    iMod (at_bor_acc_tok with "LFT ‚Ä† Œ∫") as "(>‚Ä†'&W)". solve_ndisj. solve_ndisj. iDestruct "own" as "[‚Ä†''|>%to_false]"; [|rewrite to_false in g; lia].
    destruct (decide (l = a)) as [->|?]. iAssert (‚ñ∑False)%I with "[-]" as ">[]". iNext. iApply (no_duplicate_freeable with "‚Ä†' ‚Ä†''").
    iMod ("W" with "[‚Ä†']") as "Œ∫". iNext. done.
    rewrite not_elem_of_cons bi.pure_and. iMod ("IH" with "‚Ä†s [‚Ä†''] Œ∫") as "($&Œ∫&$)". iLeft. done. iFrame. done.
    iModIntro. iSplit; [|done]. iApply proph_obs_true=>œÄ. simpl. eapply list_filter_True', Forall_fmap, Forall_impl. done. intros [??]. done.
  Qed.
  Next Obligation. intros. destruct (decide ((ty_size ty) > 0)%Z); [|done].
    iIntros "?". iExists [], _. simpl. iFrame. iPureIntro. fun_ext=>œÄ. rewrite /ghostptrtoken_mut_mod /prod_map. simpl. 
    erewrite list_filter_iff, list_filter_True. destruct (vœÄ œÄ). done. intros [??]. rewrite elem_of_nil. simpl. intuition.
  Qed.

  Lemma ghostptrtoken_own_uniq_alt {ùîÑ} (ty: type ùîÑ) Œ∫: 
    (ty_size ty > 0) ‚Üí (ty_own (uniq_alt_ty Œ∫ (ghostptrtoken_ty ty))) = ghostptrtoken_ty_uniq_alt_base ty Œ∫.
  Proof.
    replace (ty_own (uniq_alt_ty Œ∫ (_))) with (ty_uniq_alt Œ∫); [|done]. simpl.
    intros. destruct (decide (ty.(ty_size) > 0)%Z); [|lia]. done.
  Qed.


  Definition ghostptrtoken_take_mut {ùîÑ} (ty: type ùîÑ) : val :=
    fn: ["t"; "b"] :=
      delete [ #1; "t"];;
      Skip;;
      return: ["b"].

  Lemma uniq_body_irrel {ùîÑ} (inhœÄ: proph ùîÑ) (ty: type ùîÑ) (vœÄ: proph ùîÑ) (Œæi: positive) (d: nat)
      (Œ∫: lft) (tid: thread_id) (l: loc): uniq_body ty vœÄ Œæi d Œ∫ tid l = (
    let Œæ := PrVar (ùîÑ ‚Üæ prval_to_inh inhœÄ) Œæi in
    .VO[Œæ] vœÄ d ‚àó
    &{Œ∫} (‚àÉvœÄ' d', ‚ßñ(S d') ‚àó .PC[Œæ, ty.(ty_proph)] vœÄ' d' ‚àó l ‚Ü¶‚àó: ty.(ty_own) vœÄ' d' tid))%I.
    Proof. erewrite (proof_irrel (prval_to_inh _) ). done. Qed. 

  Lemma pv_irrel {ùîÑ} (Œæi: positive) (œÄ: proph_asn) (inhœÄ: proph ùîÑ) (inhœÄ': proph ùîÑ): œÄ (PrVar (ùîÑ ‚Üæ prval_to_inh inhœÄ) Œæi) = œÄ (PrVar (ùîÑ ‚Üæ prval_to_inh inhœÄ') Œæi) :> ùîÑ.
  Proof. erewrite (proof_irrel (prval_to_inh _) ). done. Qed. 

  (* Rust's GhostPtrToken::borrow_mut *)
  Lemma ghostptrtoken_take_mut_type {ùîÑ} (ty: type ùîÑ) (Œ± Œ≤: lft):
  (ty.(ty_size) > 0) ‚Üí
    typed_val (ghostptrtoken_take_mut ty) (fn(‚àÖ; &uniq{Œ±} (uniq_alt_ty Œ≤ (ghostptrtoken_ty ty)), ptr) ‚Üí &uniq{Œ≤} ty)
      (Œª post '-[((ol, ol'), (nl, nl')); ptr], exists v, (list_to_gmap ol) !! ptr = Some(v) ‚àß 
        (<[ptr:=v]>(list_to_gmap nl) = (list_to_gmap ol) ‚Üí
         (list_to_gmap nl') !! ptr = None ‚Üí
          forall v', ((list_to_gmap ol') = <[ptr:=v']>(list_to_gmap nl')) ‚Üí post (v, v'))).
  Proof. intros ?.
    fold of_syn_type. eapply type_fn; [apply _|]=> ???[ol[pl[]]]. simpl_subst.
    iIntros (?(lœÄœÄ & pœÄ &[]) ?) "#LFT #TIME #PROPH #UNIQ #E Na L C /=(ol & p &_) #Obs".
    rewrite !tctx_hasty_val. iDestruct "ol" as ([|dm]) "[_ ol]"=>//.
    case ol as [[|ol|]|]=>//. iDestruct "ol" as "[(%oll & >‚Ü¶ol & [#LftIn uniq]) ‚Ä†ol]".
    case oll as [|[[|m|]|][]]; try by iDestruct "uniq" as ">[]".
    iDestruct "p" as ([|dx]) "[‚ßñp p]"=>//. case pl as [[|pl|]|]=>//=.
    iDestruct "p" as "[p' ‚Ä†p]".
    wp_bind (delete _). iApply (wp_cumulative_time_receipt with "TIME"); [done|]. rewrite freeable_sz_full.
    iApply ((wp_delete [ #m])with "[‚Ü¶ol ‚Ä†ol]"); [done| by iFrame|]. 
    iNext. iIntros "_ ‚ßó".
    iDestruct "p'" as (?) "(‚Ü¶p&(%p&->&->))". simpl.
    iDestruct "uniq" as (du Œæi [? Eq2]) "[OVo OBor]".
    move: Eq2. set Œæ := PrVar _ Œæi => Eq2.
    iMod (lctx_lft_alive_tok Œ≤ with "E L") as (?) "(Œ≤ & L & ToL)"; [solve_typing..|].
    iMod (lctx_lft_alive_tok Œ± with "E L") as (?) "(Œ± & L & ToL2)"; [solve_typing..|].
    iMod (bor_acc with "LFT OBor Œ±") as "[(%&%& #‚ßñu & OPc & (%vl&‚Ü¶utoken&uniq')) ToOBor]"; [done|].
    rewrite ghostptrtoken_own_uniq_alt.
    iDestruct "uniq'" as (? lœÄœÄ') "(>%EqAlt&at‚Ä†s&#Œ≤in&%l'&>->&%dv&%Œ∂i&>[% %Eq3]&[Vo Bor])".
    wp_seq. iCombine "‚ßñp ‚ßñu" as "#‚ßñ". simpl.
    iDestruct (uniq_agree with "OVo OPc") as %[<-<-].
    move: Eq3. set Œ∂ := PrVar _ Œ∂i => Eq3.
    iMod (bor_acc_cons with "LFT Bor Œ≤") as "[(%&%&_& Pc & ‚Ü¶token) ToBor]"; [done|].
    iMod (uniq_strip_later with "Vo Pc") as (<- <-) "[Vo Pc]". setoid_rewrite split_mt_token.
    wp_seq. 
    iDestruct "‚Ü¶token" as (aœÄl) "(%Eq1&‚Ü¶l&‚Ü¶tys‚Ä†)".
    remember ((list_to_gmap aœÄl) !! p) as vœÄ. symmetry in HeqvœÄ. destruct vœÄ as [vœÄ|]; last first.
    iMod (proph_obs_sat with "PROPH Obs") as %(œÄw&obs). done.
    exfalso. move: (equal_f Eq1 œÄw) (equal_f EqAlt œÄw). simpl.
    destruct (lœÄœÄ œÄw) as [[??][??]]. destruct (lœÄœÄ' œÄw) as [??]. rewrite /ghostptrtoken_mut_mod. simpl.
    intros ->[= ->->].
    destruct obs as (v&obs&_). 
    rewrite /alapply list_to_map_fmap
    lookup_fmap HeqvœÄ in obs. done.
    destruct (elem_of_list_to_map_2' _ _ _ HeqvœÄ) as (rœÄ&perm&reinsert).
    iEval (rewrite perm 2! big_sepL_cons) in "‚Ü¶tys‚Ä†".
    iDestruct "‚Ü¶tys‚Ä†" as "((‚Ü¶ty&‚Ü¶tys)&(‚Ä†&‚Ä†s))".
    iMod (uniq_intro (ùîÑ:=list‚Çõ (loc‚Çõ * ùîÑ)) (alapply rœÄ) with "PROPH UNIQ") as (Œ∂'i) "[Vo' Pc']"; [done|].
    set Œ∂' := PrVar _ Œ∂'i. iDestruct (uniq_proph_tok with "Vo' Pc'") as "(Vo' & Œ∂' & Pc')".
    iMod (uniq_intro vœÄ with "PROPH UNIQ") as (Œ∑i) "[RVo RPc]"; [done|].
    set Œ∑ := PrVar _ Œ∑i. iDestruct (uniq_proph_tok with "RVo RPc") as "(RVo & Œ∑ & RPc)".
    rewrite 2! proph_tok_singleton.
    iDestruct (proph_tok_combine with "Œ∑ Œ∂'") as (?) "[Œ∑Œ∂ ToŒ∑Œ∂]".
    iMod (uniq_preresolve Œ∂ _ (Œª œÄ, (p, (œÄ Œ∑)) :: (œÄ Œ∂'))
    with "PROPH Vo Pc Œ∑Œ∂") as "(#Obs' & Œ∑Œ∂ & ToPc)"; [done| |].
    apply proph_dep_constr2; [apply proph_dep_constr|]; apply proph_dep_one.
    iMod ((uniq_update Œæ ((Œª œÄ, ghostptrtoken_mut_mod (p::ll) (al_fmap _ rœÄ, œÄ Œ∂')))) with "UNIQ OVo OPc") as "[OVo OPc]"; [done|].
    iDestruct ("ToŒ∑Œ∂" with "Œ∑Œ∂") as "[Œ∑ Œ∂']".
    (* iMod (uniq_resolve Œæ with "PROPH OVo OPc Œ∂'") as "(Obs''&OPc&Œ∂')"; [done| |]; last first. *)
    iCombine "Obs' Obs" as "#?". iClear "Obs".
    iSpecialize ("Pc'" with "Œ∂'"). iSpecialize ("RPc" with "Œ∑").
    iMod ("ToBor" $! (_‚àó_‚àó(‚Ä† p ‚Ä¶ ty_size ty))%I with "[ToPc ‚ßó] [Pc' RPc ‚Ü¶tys ‚Ü¶l ‚Ü¶ty ‚Ä† ‚Ä†s]")
      as "[Bor Œ≤]"; last first.
    - iMod (bor_sep with "LFT Bor") as "(BorR&BorK)"; [done|].
    iMod (bor_sep with "LFT BorK") as "(BorK&Bor‚Ä†)"; [done|].
    iAssert (|={_}=>  ‚åúp ‚àâ ll‚åù  ‚àó q'.[Œ≤] ‚àó _  ‚àó (big_sepL _ _))%I with "[Œ≤ Bor‚Ä† at‚Ä†s]" as ">(%pNotIn&Œ≤&Bor‚Ä†&at‚Ä†s)".
    clear EqAlt. iInduction ll as [|] "IH". iFrame. iModIntro. iSplit; [|iExact "Bor‚Ä†"]. iPureIntro. apply not_elem_of_nil.
    iDestruct "at‚Ä†s" as "(at‚Ä†'&at‚Ä†s)". destruct (decide (p = a)) as [<-|?].
    iDestruct "Œ≤" as "(Œ≤&Œ≤')". iMod (bor_acc with "LFT Bor‚Ä† Œ≤") as "(>‚Ä†&_)". done.
    iMod (at_bor_acc_tok with "LFT at‚Ä†' Œ≤'") as "(>‚Ä†'&_)". done. done. iDestruct (no_duplicate_freeable with "‚Ä† ‚Ä†'") as "[]".
    iMod ("IH" with "Œ≤ Bor‚Ä† at‚Ä†s") as "(%&$&$&$)". iFrame. iPureIntro. apply not_elem_of_cons; done.
    iMod (bor_share_lftN with "Bor‚Ä†") as "at‚Ä†"; [done|].
    iMod ("ToOBor" with "[OPc ‚Ü¶utoken Œ≤in Vo' BorK at‚Ä†s at‚Ä†]") as "[OBor Œ±]".
    {iNext. iExists _, _. iFrame "OPc ‚ßñu". iExists _. iFrame "‚Ü¶utoken Œ≤in".
    iExists _, _. iSplit. unfold compose. done. iFrame.
    iExists _, _. iSplit. iSplit. done. done.
    iFrame "Vo' BorK". }
    wp_seq.
    iMod ("ToL2" with "Œ± L") as "L". iMod ("ToL" with "Œ≤ L") as "L".
    iApply (type_type +[#m ‚óÅ &uniq{Œ±} (uniq_alt_ty Œ≤ (ghostptrtoken_ty ty)); #pl ‚óÅ box (&uniq{Œ≤} ty)] -[(Œª œÄ, (_, œÄ Œæ)); (Œª œÄ, (vœÄ œÄ, œÄ Œ∑))]
    with "[] LFT TIME PROPH UNIQ E Na L C [-] []").
    iApply type_jump; [solve_typing|solve_extract|solve_typing].
    iSplitL "OVo OBor"; [|iSplitL; [|done]]; rewrite (tctx_hasty_val #_);
    iExists _. simpl. iFrame "‚ßñu". iFrame "LftIn".
    iExists du, _.  
    erewrite uniq_body_irrel. rewrite ghostptrtoken_own_uniq_alt; [|done]. iFrame.
    iPureIntro. split. done. fun_ext=>œÄ. simpl. erewrite pv_irrel. done.
    iFrame "‚ßñu ‚Ä†p". iNext. rewrite split_mt_uniq_bor. iFrame "Œ≤in". 
    iExists _, _, _. rewrite heap_mapsto_vec_singleton. iFrame "‚Ü¶p RVo BorR". done.
    simpl. iApply proph_obs_impl; [|done] => œÄ/=.
    move: (equal_f EqAlt œÄ) (equal_f Eq1 œÄ) (equal_f Eq2 œÄ) (equal_f Eq3 œÄ)=>/=.
    destruct (lœÄœÄ œÄ) as [??]. destruct (lœÄœÄ' œÄ) as [??]. simpl.
    move=> ->->->->/= [-> ToImp] res. 
    rewrite res /alapply 2! list_to_map_fmap reinsert lookup_fmap lookup_insert in ToImp. 
    simpl. destruct ToImp as (v&[= <-]&Imp). apply Imp. rewrite fmap_insert. done.
    apply not_elem_of_list_to_map_1. rewrite elem_of_list_fmap. 
    intros ([??]&->&[[??]%not_elem_of_cons _]%elem_of_list_filter). done.
    erewrite (list_filter_iff _ _ (œÄ Œ∂')). erewrite <- list_filter_filter.
    erewrite <- (delete_list_to_map p). rewrite insert_delete_insert filter_cons.
    destruct (decide (p ‚àâ ll)). apply list_to_map_cons. done.  
    intros [??]. simpl. rewrite not_elem_of_cons. intuition.
    - destruct dv; [done|]. iDestruct "‚Ä†" as "[$|%]"; [|lia]. iSplitL "RPc ‚Ü¶ty". 
    iExists _, _. iFrame "RPc". iNext. iSplit. 
    iApply (persistent_time_receipt_mono with "‚ßñu"). lia.
    iApply (ty_own_mt_depth_mono with "‚Ü¶ty"). lia.
    iExists _, _. iFrame. iSplitR. iNext.
    iApply (persistent_time_receipt_mono with "‚ßñ"). lia. 
    rewrite split_mt_token. iExists _. iFrame. done. 
    - iNext. iIntros "((%vœÄ'&%d'&>‚ßñd'&Pc1&‚Ü¶ty)&(%mœÄ'&%d''&>‚ßñd''&Pc2&‚Ü¶tys)&‚Ä†)". rewrite split_mt_token.
    iCombine "‚ßñd' ‚ßñd''" as "‚ßñd".
    iMod (cumulative_persistent_time_receipt with "TIME ‚ßó ‚ßñd")
    as "‚ßñd"; [solve_ndisj|]. iDestruct "‚Ü¶tys" as "(%aœÄl'&>->&$&‚Ü¶tys&‚Ä†s)".
    iModIntro. iNext. 
    iExists (Œª œÄ, ((p, (vœÄ' œÄ)) :: (alapply aœÄl' œÄ))), _. iFrame.
    iSplitL "Pc1 Pc2 ToPc". iApply "ToPc".
    iDestruct (proph_ctrl_eqz' with "PROPH Pc1") as "Eqz1".
    iDestruct (proph_ctrl_eqz' with "PROPH Pc2") as "Eqz2".
    iApply proph_eqz_mono. 2:{
      iApply (proph_eqz_constr2 with "[Eqz1] Eqz2").
      iApply (proph_eqz_constr with "Eqz1").
    } { simpl. intros ? ([|aœÄ aœÄl'']&?&->&?&?). specialize (equal_f H2 inhabitant). done.
    inversion_clear H3. destruct H4 as (?&?&->&?). eexists _, _, _, _. split. done. split.
    rewrite H2. done. split. eexists. split; [|done]. fun_ext. 
    intros. simpl. unfold prod_map. f_equal. by injection (equal_f H2 inhabitant).
    eexists _, _. done. }
    iExists ((_, _) :: _). iSplit. iPureIntro. fun_ext=>?//. iFrame. 
    rewrite big_sepL_cons. simpl. iSplitL "‚Ü¶ty".
    iApply (ty_own_mt_depth_mono with "‚Ü¶ty"). lia.
    iApply (big_sepL_mono with "‚Ü¶tys"). iIntros (?[??]?) "‚Ü¶ty". 
    destruct d''; [done|]. simpl. iNext.
    iApply (ty_own_mt_depth_mono with "‚Ü¶ty"). lia.
    - done. 
  Qed.

End ghostptrtoken_mut.
