From lrust.typing Require Export type.
From lrust.typing Require Import array_util typing lib.vec.
Set Default Proof Using "Type".

Open Scope nat.
Implicit Type ùîÑ ùîÖ: syn_type.

Section vec_basic.
  Context `{!typeG Œ£}.

  Global Instance vec_type_contractive ùîÑ : TypeContractive (vec_ty (ùîÑ:=ùîÑ)).
  Proof.
    split; [by apply type_lft_morphism_id_like|done| |].
    - move=>/= > ->*. do 19 (f_contractive || f_equiv). by simpl in *.
    - move=>/= > ->*. do 16 (f_contractive || f_equiv). by simpl in *.
  Qed.

  Global Instance vec_send {ùîÑ} (ty: type ùîÑ) : Send ty ‚Üí Send (vec_ty ty).
  Proof. move=> ?>/=. by do 19 f_equiv. Qed.

  Global Instance vec_sync {ùîÑ} (ty: type ùîÑ) : Sync ty ‚Üí Sync (vec_ty ty).
  Proof. move=> ?>/=. by do 16 f_equiv. Qed.

  Lemma vec_leak {ùîÑ} (ty: type ùîÑ) Œ¶ E L :
    leak E L ty Œ¶ ‚Üí leak E L (vec_ty ty) (lforall Œ¶).
  Proof.
    iIntros (Lk ? q ?[|]???) "#LFT #PROPH #E L vec //=".
    iDestruct "vec" as (?? l aœÄl[->->]) "[‚Ü¶tys _]". iIntros "!>!>!>".
    rewrite trans_big_sepL_mt_ty_own. iDestruct "‚Ü¶tys" as (?) "[‚Ü¶ tys]".
    iMod (leak_big_sepL_ty_own with "LFT PROPH E L tys") as "Upd"; [done..|].
    iApply (step_fupdN_wand with "Upd"). by iIntros "!> ?".
  Qed.

  Lemma vec_leak_just {ùîÑ} (ty: type ùîÑ) E L :
    leak E L ty (const True) ‚Üí leak E L (vec_ty ty) (const True).
  Proof. move=> ?. apply leak_just. Qed.

  Lemma vec_real {ùîÑ ùîÖ} (ty: type ùîÑ) (f: ùîÑ ‚Üí ùîÖ) E L :
    real E L ty f ‚Üí real (ùîÖ:=list‚Çõ _) E L (vec_ty ty) (map f).
  Proof.
    move=> Rl. split; iIntros (???[|]) "*% LFT E L vec //=".
    - iDestruct "vec" as (????[->->]) "(‚Ü¶tys & ex & ‚Ä†)". iIntros "!>!>!>".
      rewrite trans_big_sepL_mt_ty_own. iDestruct "‚Ü¶tys" as (?) "[‚Ü¶ tys]".
      iMod (real_big_sepL_ty_own with "LFT E L tys") as "Upd"; [done..|].
      iApply (step_fupdN_wand with "Upd"). iIntros "!> >(%Eq &$&?) !>".
      iSplit; last first.
      { iExists _, _, _, _. iFrame "ex ‚Ä†". iSplit; [done|]. iNext.
        rewrite trans_big_sepL_mt_ty_own. iExists _. iFrame. }
      iPureIntro. move: Eq=> [bl Eq]. exists bl. fun_ext=>/= œÄ.
      move: (equal_f Eq œÄ)=>/= <-. by rewrite -vec_to_list_apply vec_to_list_map.
    - iDestruct "vec" as (????->) "[Bor tys]". iIntros "!>!>!>".
      iMod (real_big_sepL_ty_shr with "LFT E L tys") as "Upd"; [done..|].
      iIntros "!>!>". iApply (step_fupdN_wand with "Upd").
      iIntros ">(%Eq &$& tys) !>". iSplit; [|iExists _, _, _, _; by iFrame].
      iPureIntro. move: Eq=> [bl Eq]. exists bl. fun_ext=>/= œÄ.
      move: (equal_f Eq œÄ)=>/= <-. by rewrite -vec_to_list_apply vec_to_list_map.
  Qed.

  Lemma vec_subtype {ùîÑ ùîÖ} (f: ùîÑ ‚Üí ùîÖ) ty ty' E L :
    subtype E L ty ty' f ‚Üí subtype E L (vec_ty ty) (vec_ty ty') (map f).
  Proof.
    iIntros (Sub ?) "L". iDestruct (Sub with "L") as "#Sub". iIntros "!> E".
    iDestruct ("Sub" with "E") as "(%EqSz &?&#?&#?)".
    have Eq: ‚àÄ(aœÄl: vec (proph ùîÑ) _), map f ‚àò lapply aœÄl = lapply (vmap (f ‚àò.) aœÄl).
    { move=> ?. elim; [done|]=> ??? IH. fun_ext=>/= ?. f_equal. apply (equal_f IH). }
    do 2 (iSplit; [done|]). iSplit; iIntros "!>" (?[|]) "* vec //=".
    - iDestruct "vec" as (????[->->]) "(‚Ü¶tys & ex & ‚Ä†)". iExists _, _, _, _.
      rewrite !trans_big_sepL_mt_ty_own Eq EqSz. iSplit; [done|]. iFrame "ex ‚Ä†".
      iNext. iDestruct "‚Ü¶tys" as (?) "[‚Ü¶ ?]". iExists _. iFrame "‚Ü¶".
      by iApply incl_big_sepL_ty_own.
    - iDestruct "vec" as (????->) "[‚Ü¶ ?]". iExists _, _, _, _. rewrite Eq.
      iSplit; [done|]. iFrame "‚Ü¶". iNext. by iApply incl_big_sepL_ty_shr.
  Qed.
  Lemma vec_eqtype {ùîÑ ùîÖ} (f: ùîÑ ‚Üí ùîÖ) g ty ty' E L :
    eqtype E L ty ty' f g ‚Üí eqtype E L (vec_ty ty) (vec_ty ty') (map f) (map g).
  Proof. move=> [??]. split; by apply vec_subtype. Qed.

  Definition vec_new: val :=
    fn: [] :=
      let: "r" := new [ #3] in
      "r" <- #0;; "r" +‚Çó #1 <- #0;; "r" +‚Çó #2 <- new [ #0];;
      return: ["r"].

  Lemma vec_new_type {ùîÑ} (ty: type ùîÑ) :
    typed_val vec_new (fn(‚àÖ) ‚Üí vec_ty ty) (Œª post _, post []).
  Proof.
    eapply type_fn; [solve_typing|]=> _ ???. simpl_subst.
    iIntros (???) "_ #TIME _ _ _ Na L C _ Obs".
    wp_bind (new _). iApply wp_new; [done..|]. iIntros "!>" (r).
    rewrite !heap_mapsto_vec_cons shift_loc_assoc. iIntros "[‚Ä† (‚Ü¶‚ÇÄ & ‚Ü¶‚ÇÅ & ‚Ü¶‚ÇÇ &_)]".
    wp_seq. iMod persistent_time_receipt_0 as "‚ßñ". wp_bind (_ <- _)%E.
    iApply (wp_persistent_time_receipt with "TIME ‚ßñ"); [done|]. wp_write.
    iIntros "‚ßñ". wp_seq. wp_op. wp_write. wp_op. wp_bind (new _).
    iApply (wp_persistent_time_receipt with "TIME ‚ßñ"); [done|].
    iApply wp_new; [done..|]. iIntros "!>" (l) "[‚Ä†' _] ?". wp_write.
    do 2 wp_seq. rewrite cctx_interp_singleton.
    iApply ("C" $! [# #_] -[const []] with "Na L [-Obs] Obs"). iSplit; [|done].
    iExists _, _. do 2 (iSplit; [done|]). rewrite/= freeable_sz_full.
    iFrame "‚Ä†". iNext. iExists [_; _; _].
    rewrite !heap_mapsto_vec_cons shift_loc_assoc heap_mapsto_vec_nil.
    iFrame "‚Ü¶‚ÇÄ ‚Ü¶‚ÇÅ ‚Ü¶‚ÇÇ". iExists 0, 0, l, [#]. iSplit; [done|]. iFrame "‚Ä†'".
    iSplit; [by iNext|]. iExists []. by rewrite heap_mapsto_vec_nil.
  Qed.

  Definition vec_delete {ùîÑ} (ty: type ùîÑ) : val :=
    fn: ["v"] :=
      delete [(!"v" + !("v" +‚Çó #1)) * #ty.(ty_size); !("v" +‚Çó #2)];;
      delete [ #3; "v"];;
      return: [new [ #0]].

  Lemma vec_delete_type {ùîÑ} (ty: type ùîÑ) :
    typed_val (vec_delete ty) (fn(‚àÖ; vec_ty ty) ‚Üí ()) (Œª post _, post ()).
  Proof.
    eapply type_fn; [solve_typing|]=> _ ??[v[]]. simpl_subst.
    iIntros (?[?[]]?) "_ TIME _ _ _ Na L C [v _] Obs".
    rewrite tctx_hasty_val. iDestruct "v" as ([|d]) "[_ bvec]"=>//.
    case v as [[]|]=>//=. rewrite split_vec_mt.
    case d; [by iDestruct "bvec" as "[>[] _]"|]=> ?.
    iDestruct "bvec" as "[(%&%&%& big) ‚Ä†]".
    iMod (bi.later_exist_except_0 with "big") as (?) "(>-> & >‚Ü¶‚ÇÄ & >‚Ü¶‚ÇÅ & >‚Ü¶‚ÇÇ & big)".
    wp_read. wp_op. wp_read. do 3 wp_op. wp_read. rewrite trans_big_sepL_mt_ty_own.
    iDestruct "big" as "((%& ‚Ü¶old & tys) & (%& %Eq & ‚Ü¶ex) & ‚Ä†')".
    iDestruct (big_sepL_ty_own_length with "tys") as %Eq'.
    wp_bind (delete _). iApply (wp_delete _ _ _ (_ ++ _) with "[‚Ü¶old ‚Ü¶ex ‚Ä†']").
    { rewrite app_length -Nat2Z.inj_add -Nat2Z.inj_mul Nat.mul_add_distr_r.
      by do 2 f_equal. }
    { rewrite heap_mapsto_vec_app /freeable_sz' app_length
        -Nat2Z.inj_add -Nat2Z.inj_mul Nat.mul_add_distr_r Eq Eq'. iFrame. }
    iIntros "!>_". wp_seq. wp_bind (delete _).
    iApply (wp_delete _ _ _ [_;_;_] with "[‚Ü¶‚ÇÄ ‚Ü¶‚ÇÅ ‚Ü¶‚ÇÇ ‚Ä†]"); [done| |].
    { rewrite !heap_mapsto_vec_cons shift_loc_assoc heap_mapsto_vec_nil
        freeable_sz_full. iFrame. }
    iIntros "!>_". wp_seq. iMod persistent_time_receipt_0 as "‚ßñ".
    wp_bind Skip. iApply (wp_persistent_time_receipt with "TIME ‚ßñ"); [done|].
    wp_seq. iIntros "‚ßñ". wp_seq. wp_bind (new _). iApply wp_new; [done..|].
    iIntros "!>" (?) "[‚Ä† ‚Ü¶]". rewrite cctx_interp_singleton.
    iApply ("C" $! [# #_] -[const ()] with "Na L [-Obs] Obs"). iSplit; [|done].
    rewrite tctx_hasty_val. iExists _. iFrame "‚ßñ". iSplit; [|done]. iNext.
    iExists _. iFrame "‚Ü¶". by rewrite unit_ty_own.
  Qed.
End vec_basic.

Global Hint Resolve vec_leak | 5 : lrust_typing.
Global Hint Resolve vec_leak_just vec_subtype vec_eqtype : lrust_typing.
