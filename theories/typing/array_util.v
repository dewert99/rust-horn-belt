From lrust.typing Require Export type.
Set Default Proof Using "Type".

Implicit Type ùîÑ ùîÖ: syn_type.

Lemma join_app {A} (l1 l2: list (list A)): mjoin l1 ++ mjoin l2 = mjoin (l1 ++ l2).
Proof. induction l1; simpl. done. by rewrite -app_assoc IHl1. Qed. 

Notation "l +‚Çó[ ty ] i" := (l%L +‚Çó Z.of_nat (i%nat * ty.(ty_size))%nat)
  (format "l  +‚Çó[ ty ]  i", at level 50, left associativity) : loc_scope.

Notation "l ‚Ü¶‚àólen n" := (‚àÉvl, ‚åúlength vl = n%nat‚åù ‚àó l ‚Ü¶‚àó vl)%I
  (at level 20, format "l  ‚Ü¶‚àólen  n") : bi_scope.

Global Instance Forall2_proper {A B} :
  Proper (pointwise_relation _ (pointwise_relation _ (‚Üî)) ==> (=) ==> (=) ==> (‚Üî)) (@Forall2 A B).
Proof. split; subst; induction 1; constructor; by firstorder auto. Qed.

Global Instance Forall2_mono {A B} :
Proper (pointwise_relation _ (pointwise_relation _ impl) ==> (=) ==> (=) ==> impl) (@Forall2 A B).
Proof. intros ?????->??->?. eapply Forall2_impl; done.  Qed.

Lemma fmap_lapply {A B} (f: A ‚Üí B) (aœÄl: (list (proph A))) : fmap f ‚àò lapply aœÄl = lapply (fmap (f ‚àò.) aœÄl).
Proof. fun_ext=>/= ?. rewrite /lapply -2!list_fmap_compose. reflexivity. Qed.

Lemma fmap_lapply_vmap {A B} (f: A ‚Üí B) n (aœÄl: (vec (proph A) n)) : fmap f ‚àò lapply aœÄl = lapply (vmap (f ‚àò.) aœÄl).
Proof. rewrite fmap_lapply vec_to_list_map. done. Qed.

Section array_util.
  Context `{!typeG Œ£}.

  Lemma shift_loc_ty_assoc {ùîÑ} (ty: type ùîÑ) l m n :
    l +‚Çó[ty] (m + n) = l +‚Çó[ty] m +‚Çó[ty] n.
  Proof. by rewrite Nat.mul_add_distr_r shift_loc_assoc_nat. Qed.

  Lemma trans_big_sepL_mt_ty_own {ùîÑ} (ty: type ùîÑ) n (aœÄl: vec _ n) l d tid :
    ([‚àó list] i ‚Ü¶ aœÄ ‚àà aœÄl, (l +‚Çó[ty] i) ‚Ü¶‚àó: ty.(ty_own) aœÄ d tid) ‚ä£‚ä¢
    ‚àÉwll: vec (list val) n, l ‚Ü¶‚àó concat wll ‚àó
      [‚àó list] aœÄwl ‚àà vzip aœÄl wll, ty.(ty_own) aœÄwl.1 d tid aœÄwl.2.
  Proof.
    iSplit.
    - iIntros "‚Ü¶owns". iInduction aœÄl as [|] "IH" forall (l)=>/=.
      { iExists [#]. by rewrite heap_mapsto_vec_nil /=. }
      iDestruct "‚Ü¶owns" as "[(%& ‚Ü¶ & ty) ‚Ü¶owns]".
      rewrite shift_loc_0. setoid_rewrite <-shift_loc_assoc_nat.
      iDestruct ("IH" with "‚Ü¶owns") as (?) "(‚Ü¶s & tys)". iExists (_:::_).
      rewrite heap_mapsto_vec_app. iDestruct (ty_size_eq with "ty") as %->.
      iFrame.
    - iIntros "(%& ‚Ü¶s & tys)". iInduction aœÄl as [|] "IH" forall (l); [done|].
      inv_vec wll=>/= ??. rewrite heap_mapsto_vec_app.
      iDestruct "‚Ü¶s" as "[‚Ü¶ ‚Ü¶s]". iDestruct "tys" as "[ty tys]".
      iDestruct (ty_size_eq with "ty") as %->. iSplitL "‚Ü¶ ty".
      { iExists _. rewrite shift_loc_0. iFrame. }
      setoid_rewrite <-shift_loc_assoc_nat. iApply ("IH" with "‚Ü¶s tys").
  Qed.

  Lemma big_sepL_ty_own_length {ùîÑ} (ty: type ùîÑ) n (aœÄl: vec _ n) wll d tid :
    ([‚àó list] aœÄwl ‚àà vzip aœÄl wll, ty.(ty_own) aœÄwl.1 d tid aœÄwl.2) -‚àó
    ‚åúlength (concat wll) = (n * ty.(ty_size))%nat‚åù.
  Proof.
    induction aœÄl as [|??? IH]; inv_vec wll; [by iIntros|].
    iIntros (??) "/=[ty tys]". iDestruct (ty_size_eq with "ty") as %?.
    iDestruct (IH with "tys") as %?. iPureIntro. rewrite app_length. lia.
  Qed.

  Lemma ty_share_big_sepL {ùîÑ} (ty: type ùîÑ) E aœÄl d Œ∫ l tid q :
    ‚ÜëlftN ‚äÜ E ‚Üí lft_ctx -‚àó Œ∫ ‚äë ty_lft ty -‚àó
    &{Œ∫} ([‚àó list] i ‚Ü¶ aœÄ ‚àà aœÄl, (l +‚Çó[ty] i) ‚Ü¶‚àó: ty.(ty_own) aœÄ d tid) -‚àó q.[Œ∫]
      ={E}=‚àó |={E}‚ñ∑=>^d |={E}=>
        ([‚àó list] i ‚Ü¶ aœÄ ‚àà aœÄl, ty.(ty_shr) aœÄ d Œ∫ tid (l +‚Çó[ty] i)) ‚àó q.[Œ∫].
  Proof.
    iIntros (?) "#LFT #In Bor Œ∫".
    iMod (bor_big_sepL with "LFT Bor") as "Bors"; [done|].
    iInduction aœÄl as [|] "IH" forall (l q)=>/=.
    { iApply step_fupdN_full_intro. by iFrame. }
    iDestruct "Œ∫" as "[Œ∫ Œ∫‚Çä]". iDestruct "Bors" as "[Bor Bors]".
    iMod (ty_share with "LFT In Bor Œ∫") as "Toshr"; [done|].
    setoid_rewrite <-shift_loc_assoc_nat. iMod ("IH" with "Œ∫‚Çä Bors") as "Toshrs".
    iCombine "Toshr Toshrs" as "Toshrs". iApply (step_fupdN_wand with "Toshrs").
    by iIntros "!> [>[$$] >[$$]]".
  Qed.

  Lemma ty_own_proph_big_sepL {ùîÑ} (ty: type ùîÑ) n E (aœÄl: vec _ n) wll d tid Œ∫ q :
    ‚ÜëlftN ‚äÜ E ‚Üí lft_ctx -‚àó Œ∫ ‚äë ty_lft ty -‚àó
    ([‚àó list] i ‚Ü¶ aœÄwl ‚àà vzip aœÄl wll, ty.(ty_own) aœÄwl.1 d tid aœÄwl.2) -‚àó q.[Œ∫]
      ={E}=‚àó |={E}‚ñ∑=>^d |={E}=> ‚àÉŒæl q', ‚åú‚àÉ Œæll, Œæl = mjoin Œæll ‚àß Forall2 ty.(ty_proph) aœÄl Œæll‚åù ‚àó q':+[Œæl] ‚àó
        (q':+[Œæl] ={E}=‚àó
          ([‚àó list] i ‚Ü¶ aœÄwl ‚àà vzip aœÄl wll, ty.(ty_own) aœÄwl.1 d tid aœÄwl.2) ‚àó q.[Œ∫]).
  Proof.
    iIntros (?) "#LFT #In tys Œ∫". iInduction aœÄl as [|] "IH" forall (q)=>/=.
    { iApply step_fupdN_full_intro. iIntros "!>!>". iExists [], 1%Qp.
      iFrame "Œ∫". iSplit. iExists []. done.
      (iSplit; [done|]). by iIntros. }
    inv_vec wll=> ??. iDestruct "tys" as "[ty tys]". iDestruct "Œ∫" as "[Œ∫ Œ∫‚Çä]".
    iMod (ty_own_proph with "LFT In ty Œ∫") as "Upd"; [done|].
    iMod ("IH" with "tys Œ∫‚Çä") as "Upd'". iCombine "Upd Upd'" as "Upd".
    iApply (step_fupdN_wand with "Upd").
    iIntros "!> [>(%&%&%& Œæl & Toty) >(%&%&(%&->&%)& Œ∂l & Totys)] !>".
    iDestruct (proph_tok_combine with "Œæl Œ∂l") as (?) "[ŒæŒ∂l ToŒæŒ∂l]".
    iExists _, _. iFrame "ŒæŒ∂l". iSplit.
    iExists (Œæl :: Œæll). rewrite Forall2_cons. done. 
    iIntros "ŒæŒ∂l". iDestruct ("ToŒæŒ∂l" with "ŒæŒ∂l") as "[Œæl Œ∂l]".
    iMod ("Toty" with "Œæl") as "[$$]". by iMod ("Totys" with "Œ∂l") as "[$$]".
  Qed.

  Lemma ty_own_proph_big_sepL_mt {ùîÑ} (ty: type ùîÑ) n E (aœÄl: vec _ n) l d tid Œ∫ q :
    ‚ÜëlftN ‚äÜ E ‚Üí lft_ctx -‚àó Œ∫ ‚äë ty_lft ty -‚àó
    ([‚àó list] i ‚Ü¶ aœÄ ‚àà aœÄl, (l +‚Çó[ty] i) ‚Ü¶‚àó: ty.(ty_own) aœÄ d tid) -‚àó q.[Œ∫]
      ={E}=‚àó |={E}‚ñ∑=>^d |={E}=> ‚àÉŒæl q', ‚åú‚àÉ Œæll, Œæl = mjoin Œæll ‚àß Forall2 ty.(ty_proph) aœÄl Œæll‚åù ‚àó q':+[Œæl] ‚àó
        (q':+[Œæl] ={E}=‚àó
          ([‚àó list] i ‚Ü¶ aœÄ ‚àà aœÄl, (l +‚Çó[ty] i) ‚Ü¶‚àó: ty.(ty_own) aœÄ d tid) ‚àó q.[Œ∫]).
  Proof.
    rewrite {1}trans_big_sepL_mt_ty_own. iIntros (?) "LFT In (%& ‚Ü¶ & tys) Œ∫".
    iMod (ty_own_proph_big_sepL with "LFT In tys Œ∫") as "Upd"; [done|].
    iApply (step_fupdN_wand with "Upd"). iIntros "!> >(%&%&%& Œæl & Totys) !>".
    iExists _, _. iSplit; [done|]. iIntros "{$Œæl}Œæl".
    iMod ("Totys" with "Œæl") as "[tys $]". rewrite trans_big_sepL_mt_ty_own.
    iModIntro. iExists _. iFrame.
  Qed.

  Lemma ty_shr_proph_big_sepL {ùîÑ} (ty: type ùîÑ) n E (aœÄl: vec _ n) d Œ∫ tid l Œ∫' q :
    ‚ÜëlftN ‚äÜ E ‚Üí lft_ctx -‚àó Œ∫' ‚äë Œ∫ -‚àó Œ∫' ‚äë ty_lft ty -‚àó
    ([‚àó list] i ‚Ü¶ aœÄ ‚àà aœÄl, ty.(ty_shr) aœÄ d Œ∫ tid (l +‚Çó[ty] i)) -‚àó q.[Œ∫']
      ={E}‚ñ∑=‚àó |={E}‚ñ∑=>^d |={E}=> ‚àÉŒæl q', ‚åú‚àÉ Œæll, Œæl = mjoin Œæll ‚àß Forall2 ty.(ty_proph) aœÄl Œæll‚åù ‚àó q':+[Œæl] ‚àó
        (q':+[Œæl] ={E}=‚àó q.[Œ∫']).
  Proof.
    iIntros (?) "#LFT #In #In' tys Œ∫'". iInduction aœÄl as [|] "IH" forall (l q)=>/=.
    { iApply step_fupdN_full_intro. iIntros "!>!>!>!>". iExists [], 1%Qp.
      iFrame "Œ∫'". iSplit. by iExists []. (iSplit; [done|]). by iIntros. }
    iDestruct "Œ∫'" as "[Œ∫' Œ∫'‚Çä]". iDestruct "tys" as "[ty tys]".
    iMod (ty_shr_proph with "LFT In In' ty Œ∫'") as "Upd"; [done|].
    setoid_rewrite <-shift_loc_assoc_nat. iMod ("IH" with "tys Œ∫'‚Çä") as "Upd'".
    iIntros "!>!>". iCombine "Upd Upd'" as "Upd". iApply (step_fupdN_wand with "Upd").
    iIntros "[>(%&%&%& Œæl & ToŒ∫') >(%&%&(%&->&%)& Œ∂l & ToŒ∫'‚Çä)] !>".
    iDestruct (proph_tok_combine with "Œæl Œ∂l") as (?) "[ŒæŒ∂l ToŒæŒ∂l]".
    iExists _, _. iFrame "ŒæŒ∂l".
    iSplit. iExists (Œæl :: Œæll). rewrite Forall2_cons. done. 
    iIntros "ŒæŒ∂l". iDestruct ("ToŒæŒ∂l" with "ŒæŒ∂l") as "[Œæl Œ∂l]".
    iMod ("ToŒ∫'" with "Œæl") as "$". by iMod ("ToŒ∫'‚Çä" with "Œ∂l") as "$".
  Qed.

  Lemma ty_proph_weaken_big_sepL {ùîÑ} (ty: type ùîÑ) n (aœÄl: vec _ n) Œæl:
   (‚àÉ Œæll, Œæl = mjoin Œæll ‚àß Forall2 ty.(ty_proph) aœÄl Œæll) ‚Üí vapply aœÄl ./[ùîÑ] Œæl.
  Proof. 
    intros (?&->&?). revert x H. induction aœÄl; intros. done.
    destruct x. inversion H.
    rewrite vec_to_list_cons Forall2_cons in H. destruct H.
    rewrite /vapply. simpl. apply proph_dep_vec_S; unfold compose; simpl.
    by eapply ty_proph_weaken. by apply IHaœÄl.
  Qed.

  Lemma ty_proph_weaken_big_sepL' {ùîÑ} (ty: type ùîÑ) (aœÄl: list _) Œæll:
    Forall2 ty.(ty_proph) aœÄl Œæll ‚Üí lapply aœÄl ./[ùîÑ] mjoin Œæll.
  Proof. 
    intros ?. rewrite -(vec_to_list_to_vec aœÄl) -vec_to_list_apply. apply proph_dep_constr.
    eapply ty_proph_weaken_big_sepL. eexists _. rewrite vec_to_list_to_vec. done.
  Qed.

  Lemma resolve_big_sepL_ty_own {ùîÑ} (ty: type ùîÑ) Œ¶ n (aœÄl: vec _ n) wll d tid F q E L :
    resolve E L ty Œ¶ ‚Üí ‚ÜëlftN ‚à™ ‚ÜëprophN ‚äÜ F ‚Üí
    lft_ctx -‚àó proph_ctx -‚àó elctx_interp E -‚àó llctx_interp L q -‚àó
    ([‚àó list] i ‚Ü¶ aœÄwl ‚àà vzip aœÄl wll, ty.(ty_own) aœÄwl.1 d tid aœÄwl.2)
      ={F}=‚àó |={F}‚ñ∑=>^d |={F}=> ‚ü®œÄ, lforall Œ¶ (lapply aœÄl œÄ)‚ü© ‚àó llctx_interp L q.
  Proof.
    iIntros (Rslv ?) "#LFT #PROPH #E L tys".
    iInduction aœÄl as [|] "IH" forall (q).
    { iApply step_fupdN_full_intro. iFrame "L". by iApply proph_obs_true. }
    inv_vec wll=>/= ??. iDestruct "tys" as "[ty tys]". iDestruct "L" as "[L L‚Çä]".
    iMod (Rslv with "LFT PROPH E L ty") as "Upd"; [done|].
    iMod ("IH" with "L‚Çä tys") as "Upd'". iCombine "Upd Upd'" as "Upd".
    iApply (step_fupdN_wand with "Upd"). iIntros "!> [>[#? $] >[#? $]]".
    by iApply proph_obs_and.
  Qed.

  Lemma real_big_sepL_ty_own {ùîÑ ùîÖ} (ty: type ùîÑ) (f: ùîÑ ‚Üí ùîÖ) n
      (aœÄl: vec _ n) wll d tid E L F q :
    real E L ty f ‚Üí ‚ÜëlftN ‚äÜ F ‚Üí lft_ctx -‚àó elctx_interp E -‚àó llctx_interp L q -‚àó
    ([‚àó list] aœÄwl ‚àà vzip aœÄl wll, ty.(ty_own) aœÄwl.1 d tid aœÄwl.2)
      ={F}=‚àó |={F}‚ñ∑=>^d |={F}=>
        ‚åú‚àÉbl, vmap f ‚àò vapply aœÄl = const bl‚åù ‚àó llctx_interp L q ‚àó
        [‚àó list] aœÄwl ‚àà vzip aœÄl wll, ty.(ty_own) aœÄwl.1 d tid aœÄwl.2.
  Proof.
    iIntros ([Rl _]?) "#LFT #E L tys". iInduction aœÄl as [|] "IH" forall (q).
    { iApply step_fupdN_full_intro. iFrame "L tys". iPureIntro. by exists [#]. }
    inv_vec wll=>/= ??. iDestruct "tys" as "[ty tys]". iDestruct "L" as "[L L‚Çä]".
    iMod (Rl with "LFT E L ty") as "Upd"; [done|].
    iMod ("IH" with "L‚Çä tys") as "Upd'". iCombine "Upd Upd'" as "Upd".
    iApply (step_fupdN_wand with "Upd"). iIntros "!> [>(%Eq &$&$) >(%Eq' &$&$)] !%".
    move: Eq=> [b Eq]. move: Eq'=> [bl Eq']. exists (b ::: bl).
    fun_ext=>/= œÄ. by move: (equal_f Eq œÄ) (equal_f Eq' œÄ)=>/= <-<-.
  Qed.

  Lemma real_big_sepL_ty_shr {ùîÑ ùîÖ} (ty: type ùîÑ) (f: ùîÑ ‚Üí ùîÖ) n
      (aœÄl: vec _ n) d Œ∫ tid l E L F q :
    real E L ty f ‚Üí ‚ÜëlftN ‚äÜ F ‚Üí lft_ctx -‚àó elctx_interp E -‚àó llctx_interp L q -‚àó
    ([‚àó list] i ‚Ü¶ aœÄ ‚àà aœÄl, ty.(ty_shr) aœÄ d Œ∫ tid (l +‚Çó[ty] i))
      ={F}‚ñ∑=‚àó |={F}‚ñ∑=>^d |={F}=>
        ‚åú‚àÉbl, vmap f ‚àò vapply aœÄl = const bl‚åù ‚àó llctx_interp L q ‚àó
        [‚àó list] i ‚Ü¶ aœÄ ‚àà aœÄl, ty.(ty_shr) aœÄ d Œ∫ tid (l +‚Çó[ty] i).
  Proof.
    iIntros ([_ Rl]?) "#LFT #E L tys". iInduction aœÄl as [|] "IH" forall (l q)=>/=.
    { iApply step_fupdN_full_intro. iFrame "L". iPureIntro. by exists [#]. }
    iDestruct "tys" as "[ty tys]". iDestruct "L" as "[L L‚Çä]".
    setoid_rewrite <-shift_loc_assoc_nat. iMod (Rl with "LFT E L ty") as "Upd"; [done|].
    iMod ("IH" with "L‚Çä tys") as "Upd'". iCombine "Upd Upd'" as "Upd". iIntros "!>!>".
    iApply (step_fupdN_wand with "Upd"). iIntros "[>(%Eq &$&$) >(%Eq' &$&$)] !%".
    move: Eq=> [b Eq]. move: Eq'=> [bl Eq']. exists (b ::: bl).
    fun_ext=>/= œÄ. by move: (equal_f Eq œÄ) (equal_f Eq' œÄ)=>/= <-<-.
  Qed.

  Lemma incl_big_sepL_ty_own {ùîÑ ùîÖ} (ty: type ùîÑ) (ty': type ùîÖ)
      f n (aœÄl: vec _ n) wll d tid :
    ‚ñ° (‚àÄaœÄ d tid vl, ty.(ty_own) aœÄ d tid vl -‚àó ty'.(ty_own) (f ‚àò aœÄ) d tid vl) -‚àó
    ([‚àó list] aœÄwl ‚àà vzip aœÄl wll, ty.(ty_own) aœÄwl.1 d tid aœÄwl.2) -‚àó
    [‚àó list] bœÄwl ‚àà vzip (vmap (f ‚àò.) aœÄl) wll, ty'.(ty_own) bœÄwl.1 d tid bœÄwl.2.
  Proof.
    iIntros "#In tys". iInduction aœÄl as [|] "IH"; inv_vec wll; [done|]=>/= ??.
    iDestruct "tys" as "[ty tys]". iSplitL "ty"; by [iApply "In"|iApply "IH"].
  Qed.

  Lemma incl_big_sepL_ty_shr {ùîÑ ùîÖ} (ty: type ùîÑ) (ty': type ùîÖ)
      f n (aœÄl: vec _ n) d Œ∫ tid l :
    ty.(ty_size) = ty'.(ty_size) ‚Üí
    ‚ñ° (‚àÄaœÄ d Œ∫ tid l', ty.(ty_shr) aœÄ d Œ∫ tid l' -‚àó ty'.(ty_shr) (f ‚àò aœÄ) d Œ∫ tid l') -‚àó
    ([‚àó list] i ‚Ü¶ aœÄ ‚àà aœÄl, ty.(ty_shr) aœÄ d Œ∫ tid (l +‚Çó[ty] i)) -‚àó
    [‚àó list] i ‚Ü¶ bœÄ ‚àà vmap (f ‚àò.) aœÄl, ty'.(ty_shr) bœÄ d Œ∫ tid (l +‚Çó[ty'] i).
  Proof.
    iIntros (->) "#In tys". iInduction aœÄl as [|] "IH" forall (l); [done|]=>/=.
    iDestruct "tys" as "[ty tys]". setoid_rewrite <-shift_loc_assoc_nat.
    iSplitL "ty"; by [iApply "In"|iApply "IH"].
  Qed.

  Lemma incl_forall2_ty_proph {ùîÑ ùîÖ} (ty: type ùîÑ) (ty': type ùîÖ)
      f n (aœÄl: vec _ n) Œæll:
    (‚àÄaœÄ Œæl, ty.(ty_proph) aœÄ Œæl ‚Üí ty'.(ty_proph) (f ‚àò aœÄ) Œæl) ‚Üí
    (Forall2 ty.(ty_proph) aœÄl Œæll) ‚Üí (Forall2 ty'.(ty_proph) (vmap (f ‚àò.) aœÄl) Œæll).
  Proof.
    revert aœÄl Œæll; induction n; intros ?? In tys; destruct Œæll; inv_vec aœÄl; intros; inversion tys; constructor.
    by apply In. by apply IHn.
  Qed.

  Lemma incl_forall2_ty_proph' {ùîÑ ùîÖ} (ty: type ùîÑ) (ty': type ùîÖ)
      f n (aœÄl: vec _ n) Œæll:
    (‚àÄaœÄ Œæl, ty'.(ty_proph) (f ‚àò aœÄ) Œæl ‚Üí ty.(ty_proph) aœÄ Œæl) ‚Üí
    (Forall2 ty'.(ty_proph) (vmap (f ‚àò.) aœÄl) Œæll) ‚Üí
    (Forall2 ty.(ty_proph) aœÄl Œæll).
  Proof.
    revert aœÄl Œæll; induction n; intros ?? In tys; destruct Œæll; inv_vec aœÄl; intros; inversion tys; constructor.
    by apply In. by apply IHn.
  Qed.

  Lemma big_sepL_ty_shr_lft_mono {ùîÑ} (ty: type ùîÑ) aœÄl d Œ∫ Œ∫' tid l :
    Œ∫' ‚äë Œ∫ -‚àó ([‚àó list] i ‚Ü¶ aœÄ ‚àà aœÄl, ty.(ty_shr) aœÄ d Œ∫ tid (l +‚Çó[ty] i)) -‚àó
    [‚àó list] i ‚Ü¶ aœÄ ‚àà aœÄl, ty.(ty_shr) aœÄ d Œ∫' tid (l +‚Çó[ty] i).
  Proof.
    iIntros "#? tys". iInduction aœÄl as [|] "IH" forall (l); [done|]=>/=.
    iDestruct "tys" as "[ty tys]". setoid_rewrite <-shift_loc_assoc_nat.
    iSplitL "ty"; by [iApply ty_shr_lft_mono|iApply "IH"].
  Qed.

  Lemma proph_dep_vlapply m {A n} (aœÄl: vec (proph A) n) Œæl: vapply aœÄl ./{m} Œæl ‚Üî lapply aœÄl ./{m} Œæl.
  Proof. 
    rewrite -vec_to_list_apply. split; intros. apply proph_dep_constr. done.
    eapply proph_dep_destr; [|done]. typeclasses eauto.
  Qed.

  Lemma proph_eqz_vinsert' {ùîÑ n} i xœÄ yœÄ (zœÄl: vec (proph ùîÑ) n) (P: (proph ùîÑ) ‚Üí _) :
    xœÄ :={P}= yœÄ -‚àó
    vapply (vinsert i xœÄ zœÄl) :={Œª vœÄ Œæl, exists Œæll, Œæl = mjoin Œæll /\ Forall2 P (vfunsep vœÄ) Œæll}= vapply (vinsert i yœÄ zœÄl).
  Proof.
    iIntros "Eqzs". iApply proph_eqz_mono; [|iApply proph_eqz_vinsert].
    simpl. intros ? (?&->&?). rewrite semi_iso' vec_to_list_insert insert_take_drop in H.
    apply Forall2_app_inv_l in H. destruct H as (?&?&?&?&->). inversion H0.
    rewrite -join_app vapply_insert. simpl. setoid_rewrite vlookup_insert. eexists _, _, _. done.
    rewrite vec_to_list_length. apply fin_to_nat_lt. done. 
  Qed.
End array_util.
